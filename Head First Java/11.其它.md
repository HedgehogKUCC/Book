## 用 String 的 split() 解析

```java
public class SplitTest {

	public static void main(String[] args) {
		
		String toTest = "What is blue + yellow?/green";
		String[] result = toTest.split("/");
		
		for(String token : result) {
			
			System.out.println(token);
		}
	}
}
```

```cmd
What is blue + yellow?
green
```

<br>

## 紀錄 KTV 最常點的歌

<br>

SongList.txt

```txt
Communication/The Cardigans
Black Dog/Led Zeppelin
Dreams/Van Halen
Comfortably Numb/Pink Floyd
Beth/Kiss
倒退嚕/黃克林
```

<br>

```java
package Song;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;

public class Jukebox1 {
	
	// 歌曲名稱會存在 String 的 ArrayList 上
	ArrayList<String> songList = new ArrayList<String>();
	
	public static void main(String[] args) {
		
		new Jukebox1().go();
	}
	
	// 這個 method 會載入檔案並列出內容
	public void go() {
		
		getSongs();
		System.out.println(songList);
	}
	
	// 讀取檔案的程序
	void getSongs() {
		
		try {
			
			File file = new File("/Users/kucc/Desktop/SongList.txt");
			BufferedReader reader = new BufferedReader(new FileReader(file));
			
			String line = null;
			
			while((line = reader.readLine()) != null) {
				
				addSong(line);
			}
			
		} catch (Exception e) {	e.printStackTrace(); }
	}
	
	void addSong(String lineToParse) {
		
		// split() 會用 反斜線 來拆開歌曲資料
		String[] tokens = lineToParse.split("/");
		
		// 因為只需要歌名，所以只取第一項加入 SongList
		songList.add(tokens[0]);
	}
}
```

<br>

依照加入的順序列出，與原始的文字檔案順序相同。這鐵定不是歌本的排列方式！！！

```cmd
[Communication, Black Dog, Dreams, Comfortably Numb, Beth, 倒退嚕]
```

<br>

## ArrayList 不是 唯一的集合

<br>

`TreeSet`

以有序狀態保持並可***防止重複***

<br>

`HashSet`

***防止重複***的集合，可快速的找尋相符的元素

<br>

`HashMap`

可用成對的 name / value 來保存與取出

<br>

`LinkedList`

適合建構堆疊與佇列等結構

<br>

`LinkedHashMap`

類似 HashMap，但可以記住元素插入的順序，也可以設定成依照元素上次存取的先後順序。

<br>

### 你可以使用 TreeSet 或 Collections.sort()

如果你把字串放進 TreeSet 而不是 ArrayList，這些 String 會自動的依照字母順序排在正確的位置。

每當你想要列出清單時，元素總是會依字母順序出現。

<br>

### java.util.Collections

`public static <T extends Comparable<? super T>> void sort(List<T> list)`

	Collections 這個 class 有個 sort()。它會用到 List，而 ArrayList 有實作 List 這個 interface，
	
	所以 ArrayList 是一個 List。感謝多型機制，你確實可以把 ArrayList 傳給用到 List 的 method。

```java
package Song;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;

public class Jukebox2 {

ArrayList<String> songList = new ArrayList<String>();
	
	public static void main(String[] args) {
		
		new Jukebox2().go();
	}
	
	public void go() {
		
		getSongs();
		System.out.println(songList);
		
		Collections.sort(songList);		// 呼叫 Collections 靜態的 sort()
		System.out.println(songList);    // 然後再列出清單。第二次的輸出會依照字母排列
	}
	
	void getSongs() {
		
		try {
			
			File file = new File("/Users/kucc/Desktop/SongList.txt");
			BufferedReader reader = new BufferedReader(new FileReader(file));
			
			String line = null;
			
			while((line = reader.readLine()) != null) {
				
				addSong(line);
			}
			
		} catch (Exception e) {	e.printStackTrace(); }
	}
	
	void addSong(String lineToParse) {
		
		String[] tokens = lineToParse.split("/");
		songList.add(tokens[0]);
	}
}
```

```cmd
[Communication, Black Dog, Dreams, Comfortably Numb, Beth, 倒退嚕]   // 呼叫前
[Beth, Black Dog, Comfortably Numb, Communication, Dreams, 倒退嚕]   // 呼叫後
```

<br>

### 但是現在要用 Song 物件，而不只是 String

	老闆說 list 裡面要擺的是 Song 這個 class 的實體，這樣新的點歌系統才會有更細節的資料可以輸出。
	
	所以檔案內也會從兩種資料增加到四種。
	
	Song 這個 class 是很單純的。但有一項很有意思的功能 - 被 override 過的 toString()。
	
	要知道 toString() 是定義在 Object 這個 class 中，所以 Java 中的每個 class 都有繼承到。
	
	且因為物件被 System.out.println(anObject) 列出來時會被呼叫 toString()，
	
	所以當你要把 list 列出時，每個物件的 toString() 都會被呼叫一次。

```java
package Song;

public class Song {

	// 對應四種屬性的四個實體變數
	String title;
	String artist;
	String rating;
	String bpm;
	
	// 變數都會在建構時從 constructor 中設定
	public Song(String t, String a, String r, String b) {
		
		title = t;
		artist = a;
		rating = r;
		bpm = b;
	}

	// 四種屬性的 getter
	public String getTitle() {
		return title;
	}

	public String getArtist() {
		return artist;
	}

	public String getRating() {
		return rating;
	}

	public String getBpm() {
		return bpm;
	}
	
	// 將 toString() override 過，讓它回傳歌名。
	public String toString() {
		
		return title;
	}
}
```

<br>

SongListMore.txt &nbsp; &nbsp; &nbsp; // 新的歌曲檔帶有四項屬性。所以我們需要建構出 Song 的實體變數來帶這些屬性

```txt
Communication/The Cardigans/5/80
Black Dog/Led Zeppelin/4/84
Dreams/Van Halen/6/120
Comfortably Numb/Pink Floyd/5/110
Beth/Kiss/4/100
倒退嚕/黃克林/5/90
```

<br>

### 修改點歌系統程式

```java
package Song;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;

public class Jukebox3 {

	// 將 String 改成 Song 型別
	ArrayList<Song> songList = new ArrayList<Song>();
	
	public static void main(String[] args) {
		
		new Jukebox3().go();
	}
	
	public void go() {
		
		getSongs();
		System.out.println(songList);
		
		Collections.sort(songList);
		System.out.println(songList);
	}
	
	void getSongs() {
		
		try {
			File file = new File("/Users/kucc/Desktop/SongListMore.txt");
			BufferedReader reader = new BufferedReader(new FileReader(file));
			String line = null;
			while((line = reader.readLine()) != null) {
				addSong(line);
			}
		} catch (Exception ex) { ex.printStackTrace(); }
	}
	
	void addSong(String lineToParse) {
		
		String[] tokens = lineToParse.split("/");
		
		// 使用解析出來的四項屬性來建構 Song 物件並加入到 list 中
		Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);
		songList.add(nextSong);
	}
}
```

<br>

### 無法通過編譯

有點問題...Collections 很明顯的說明 sort() 這個 method 會取用 List。

ArrayList 是一個 List ，因為 ArrayList 有實作 List 這個 interface，所以應該要沒問題才對。

但就是不行！！！

編譯器表示它找不到取用 `ArrayList<Song>` 參數的 sort()，

所以 `ArrayList<String>` 與 `ArrayList<Song>` 之間到底有什麼差異？

為什麼編譯器不會讓它過關？

<br>

從 API 說明文件找 java.util.Collections 下面的 sort()

`public static <T extends Comparable<? super T>> void sort(List<T> list)`

這是因為 sort() 有很大量的運用到 generic (泛型) 功能。

只要你在 Java 的程式或文件中看到 <&nbsp; &nbsp;> 這一組符號，就代表 generic 正在作用 - 它是一種從 Java 5.0 開始加入的特質。

看起來我們得先學會如何解讀說明文件才能看得出來

為何 ArrayList 可應付 String 物件，

但不吃 Song 物件。

	運用 generic 你就可以建構型別安全更好的集合，讓問題盡可能在編譯期就能抓到，而不會等到執行期才冒出來。
	
	如果沒有 generic ，編譯器會很愉快的接受你把 綿羊物件 送到 老虎集合中。

<br>

### 怪異之處

這行程式：

`public <T extends Animal> void takeThing(ArrayList<T> list)`

跟這個是不一樣的：

`public void takeThing(ArrayList<Animal> list)`

兩者都合法，但意義不同！！！

首先，`<T extends Animal>` 是 method 宣告的一部份，表示任何被宣告為 Animal 或 Animal 的 subtype (像是 Cat 或 Dog) 的 ArrayList 是合法的。

因此你***可以使用 `ArrayList<Dog>`、`ArrayList<Cat>` 或 `ArrayList<Animal>`*** 來叫用上面的 method。

但是...下面的 method 的參數是 `ArrayList<Animal>` list，代表***只有 `ArrayList<Animal>` 是合法的***。

也就是說第一個可以使用任何一種 Animal 的 ArrayList，

而第二個 method 只能使用 Animal 的 ArrayList。

<br>

### 出錯的地方

// 就是這裡有問題！傳入 `ArrayList<String>`可以過關，但`ArrayList<Song>` 就不行。

`Collections.sort(songList);`

<br>

`public static <T extends Comparable<? super T>> void sort(List<T> list)`

`<T extends Comparable` &nbsp; &nbsp; &nbsp; // 這表示它必須是 Comparable

`(List<T>` &nbsp; &nbsp; &nbsp; // 僅能傳入 extend 過 Comparable 的參數化型別的 list

<br>

### 以泛型的觀點來說，extends 代表 extend 或 implement

// String 有 implements `Comparable<String>`，所以傳入 `ArrayList<String>`可以過關。

`public final class String
extends Object
implements Serializable, Comparable<String>, CharSequence`

<br>

### Song.java 必須實作 Comparable

```java
```